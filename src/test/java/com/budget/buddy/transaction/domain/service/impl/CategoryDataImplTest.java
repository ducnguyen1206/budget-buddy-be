package com.budget.buddy.transaction.domain.service.impl;

import com.budget.buddy.transaction.application.dto.category.CategoryDTO;
import com.budget.buddy.transaction.application.mapper.CategoryMapper;
import com.budget.buddy.transaction.domain.enums.CategoryType;
import com.budget.buddy.transaction.domain.model.category.Category;
import com.budget.buddy.transaction.domain.vo.CategoryVO;
import com.budget.buddy.transaction.infrastructure.repository.CategoryRepository;
import com.budget.buddy.user.application.service.user.UserService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class CategoryDataImplTest {

    @InjectMocks
    private CategoryDataImpl transactionData;

    @Mock
    private UserService userService;

    @Mock
    private CategoryRepository categoryRepository;

    @Mock
    private CategoryMapper categoryMapper;

    private final String email = "test@example.com";

    /**
     * Test to verify that a category is successfully created when valid input is provided.
     */
    @Test
    void shouldCreateCategorySuccessfully() {
        // Arrange

        Long userId = 1L;

        CategoryVO categoryVO = new CategoryVO("Food", CategoryType.EXPENSE);

        CategoryDTO categoryRequest = new CategoryDTO(null, "Food", CategoryType.EXPENSE);
        Category categoryEntity = new Category(categoryVO, userId);
        categoryEntity.setId(10L); // Assuming id is auto-generated by the persistence layer
        CategoryDTO expectedResponse = new CategoryDTO(10L, "Food", CategoryType.EXPENSE);

        when(userService.findUserIdByEmail(email)).thenReturn(userId);
        when(categoryRepository.findByIdentity_NameAndIdentity_Type(
                categoryRequest.name(), categoryRequest.type())).thenReturn(java.util.Optional.empty());
        when(categoryRepository.save(any(Category.class))).thenReturn(categoryEntity);
        when(categoryMapper.toDto(any(Category.class))).thenReturn(expectedResponse);

        // Act
        CategoryDTO actualResponse = transactionData.createCategory(categoryRequest);

        // Assert
        assertEquals(expectedResponse.id(), actualResponse.id());
        assertEquals(expectedResponse.name(), actualResponse.name());
        assertEquals(expectedResponse.type(), actualResponse.type());
        Mockito.verify(userService).findUserIdByEmail(email);
        Mockito.verify(categoryRepository).findByIdentity_NameAndIdentity_Type(
                categoryRequest.name(), categoryRequest.type());
        Mockito.verify(categoryRepository).save(any(Category.class));
    }

    /**
     * Test to verify that a category is not created when the user email does not exist.
     */
    @Test
    void shouldThrowErrorWhenUserEmailNotFound() {
        // Arrange

        CategoryDTO categoryRequest = new CategoryDTO(null, "Food", CategoryType.EXPENSE);

        when(userService.findUserIdByEmail(email)).thenThrow(new IllegalArgumentException("User not found."));

        // Act & Assert
        var exception = org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class,
                () -> transactionData.createCategory(categoryRequest));

        assertEquals("User not found.", exception.getMessage());

        Mockito.verify(userService).findUserIdByEmail(email);
        Mockito.verifyNoInteractions(categoryRepository);
    }

    /**
     * Test to verify the behavior when the repository fails to save the category.
     */
    @Test
    void shouldThrowErrorWhenRepositoryFailsToSaveCategory() {
        // Arrange

        Long userId = 1L;

        CategoryDTO categoryRequest = new CategoryDTO(null, "Food", CategoryType.EXPENSE);

        when(userService.findUserIdByEmail(email)).thenReturn(userId);
        when(categoryRepository.save(any(Category.class))).thenThrow(new RuntimeException("Database error"));

        // Act & Assert
        try {
            transactionData.createCategory(categoryRequest);
        } catch (RuntimeException ex) {
            assertEquals("Database error", ex.getMessage());
        }

        Mockito.verify(userService).findUserIdByEmail(email);
        Mockito.verify(categoryRepository).save(any(Category.class));
    }

    /**
     * Test to verify that no new category is created if a category with the same name and type
     * already exists for the user.
     */
    @Test
    void shouldReturnExistingCategoryIfAlreadyExists() {
        // Arrange
        Long userId = 1L;

        CategoryDTO categoryRequest = new CategoryDTO(null, "Food", CategoryType.EXPENSE);
        Category existingCategory = new Category(new CategoryVO("Food", CategoryType.EXPENSE), userId);
        existingCategory.setId(10L);
        CategoryDTO expectedResponse = new CategoryDTO(10L, "Food", CategoryType.EXPENSE);

        when(userService.findUserIdByEmail(email)).thenReturn(userId);
        when(categoryRepository.findByIdentity_NameAndIdentity_Type(
                categoryRequest.name(), categoryRequest.type())).thenReturn(java.util.Optional.of(existingCategory));
        when(categoryMapper.toDto(existingCategory)).thenReturn(expectedResponse);

        // Act
        CategoryDTO actualResponse = transactionData.createCategory(categoryRequest);

        // Assert
        assertEquals(expectedResponse.id(), actualResponse.id());
        assertEquals(expectedResponse.name(), actualResponse.name());
        assertEquals(expectedResponse.type(), actualResponse.type());
        Mockito.verify(userService).findUserIdByEmail(email);
        Mockito.verify(categoryRepository).findByIdentity_NameAndIdentity_Type(
                categoryRequest.name(), categoryRequest.type());
    }
}